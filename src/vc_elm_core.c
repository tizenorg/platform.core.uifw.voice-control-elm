/*
 * Copyright (c) 2011-2014 Samsung Electronics Co., Ltd All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "vc_elm_main.h"
#include <assert.h>
#include <libintl.h>
#include <stdbool.h>
#include <stdlib.h>
#include <Ecore_Evas.h>
#include <libxml/parser.h>
#include <voice_control_widget.h>

#include "vc_elm.h"
#include "vc_elm_core.h"
#include "vc_elm_tools.h"
#include "vc_elm_widget_wrapper.h"
#include "vc_elm_tooltip.h"
#include "vc_elm_rectangle.h"

#ifdef _
#undef _
#endif
#define _VC_ELM(S) dgettext("voice-control-elm", S)
#define _APP(S) dgettext(g_app_domain, S)

#define XML_CAST (const xmlChar *)

static char *g_app_domain = NULL;

static Evas_Object *g_default_window = NULL;
static Eina_Hash *g_widget_info_hash = NULL;
static Eina_Hash *item_hint_map = NULL;
static Eina_Hash *item_command_map = NULL;
static Eina_Hash *item_custom_map = NULL;
static Eina_Hash *command_item_map = NULL;
static Eina_Hash *registered_item_map = NULL;
static Eina_List *g_wrapped_commands = NULL;
static Eina_List *ui_objects_list = NULL;
static Eina_List *g_current_ui_objects = NULL;
static Eina_Bool g_tooltips_displayed = EINA_FALSE;
static Eina_Bool g_hints_autogenerated = EINA_TRUE;

static Eina_Hash *g_config_action_map = NULL;
static Eina_Hash *g_config_widget_map = NULL;

static char *g_tooltips_image_path = NULL;
static char *g_tooltips_default_direction = NULL;
static char *g_tooltips_show = NULL;

static Ecore_Timer *g_animation_view_idler = NULL;
static Eina_Bool g_view_changed = EINA_FALSE;

#define HIDE 0xa
#define X_VISIBILITY_TOLERANCE 32.0
#define Y_VISIBILITY_TOLERANCE 54.0

static void   __idle_changed(Ecore_Evas *ee);
const Eina_Hash *_vc_elm_core_get_config_action_map()
{
	return g_config_action_map;
}

const Eina_Hash *_vc_elm_core_get_config_widget_map()
{
	return g_config_widget_map;
}

/**
 * @brief Structure that wrapps a command with corresponding widget and it's parent
 */
struct Wrapped_Command {
	const char *cmd;
	void *data;
	Evas_Object *obj;
	Elm_Object_Item *parent_item;
	void (*unwrap_callback)(struct Wrapped_Command *wrapper, const char *action, const char *param);
};

/**
 * @brief Structure that wrapps a wrapped command with it's command and param
 */
struct Unwrapped_Command {
	struct Wrapped_Command *wrap;
	char *action;
	char *param;
};

/**
 * @brief Structure defines a custom tooltip
 */
struct Custom_Data {
	const char *image_path;
	int pos_x;
	int pos_y;
};

/* functions private to vc_elm_core module */

/**
 * @brief Function that is called repeatedly to free widget info hashmap elements
 * @param[in] element to deallocate
 */
static void __widget_info_free_cb(void *entry);

/**
 * @brief Function that is called repeatedly to free widget info hashmap elements
 * @param[in] element to deallocate
 */
static void __hash_entry_dummy_cb(void *entry);

/**
 * @brief Function that is called repeatedly to free object's hashmap elements
 * @param[in] element to deallocate
 */
static void __hash_entry_free_cb(void *entry);

/**
 * @brief Function that recursively traverses the widget tree and finds visible
 *		widgets that can have widgets and commands
 * @param[in] current widget to handle
 * @param[in] callback to handle traversing the current widget
 * @param[in] current list of found widgets
 */
static void __elm_widget_foreach_in_tree(Evas_Object *widget, Eina_Bool(*cb)(Evas_Object *widget, Eina_List **data), Eina_List **data);

/**
 * @brief Function that recursively traverses the widget tree and finds visible
 *		widgets that can have widgets and commands. This handle special cases
 *		of some widgets that have subwidgets
 * @param[in] current widget to handle
 * @param[in] current list of found widgets
 */
static Eina_Bool __elm_widget_foreach_to_list_add(Evas_Object *widget, Eina_List **list);

/**
 * @brief Function that commits the gathered commands
 */
static void __vc_add_commands();

/**
 * @brief Callback that handles recognition output
 * @param[in] recognized command
 * @param[in] recognized first param
 * @param[in] recognized second param (unused)
 * @param[in] extra data to be passed to function
 */
static int __result_cb(const char *cmd, const char *param1, const char *param2, void *user_data);
/**
 * @brief Function to handle command activation - also handles special cases
 *		when visibility checks need to be performed; possibly scrolling or
 *		bringing in activated invisible widgets
 * @param[in] command structure to be activated
 * @param[in] recognized action
 * @param[in] recognized param
 */
static void __unwrap_universal_item_command(struct Wrapped_Command *wrapper, const char *action, const char *param);

/**
 * @brief Callback that shows or hides tooltips
 * @param[in] whether to hide or show the tooltips
 */
static void __show_or_hide_tooltips_callback(bool show_or_hide);

/**
 * @brief Callback that relayouts the tooltips in case of screen rotation
 * @param[in] data to pass to callback (unused)
 * @param[in] Evas_Object to pass to callback (unused)
 * @param[in] callback's data to pass (unused)
 */
static void __rotation(void *data, Evas_Object *obj, void *event_info);

static int __is_hidden_widget(Evas_Object *obj);


/**
 * @brief Function that returns the name of the widget
 * @param[in] handle to widget's Evas_Object structure
 */
const char *_get_ui_object_name(const Evas_Object *obj)
{
	const char *ret = evas_object_data_get(obj, _vc_elm_get_custom_widget_name());
	if (!ret)
		ret = elm_widget_type_get(obj);
	if (!ret)
		ret = evas_object_name_get(obj);
	ret = eina_stringshare_add(ret);
	return ret;
}

/**
 * @brief Function that matches recognition result to the registered actions
 *		and calls for action execution
 * @param[in] recognized command
 * @param[in] recognized action
 * @param[in] recognized param
 */
Eina_Bool _recognize_command(const char *cmd, const char *param1, const char *param2)
{
	const Eina_List *l;
	struct Wrapped_Command *wrapped;
	struct Wrapped_Command *found = NULL;
	VC_ELM_LOG_INFO("Trying to recognize %s %s %s", cmd, param1, param2);

	EINA_LIST_FOREACH(g_wrapped_commands, l, wrapped) {
		VC_ELM_LOG_DBG("compare %s %s", wrapped->cmd, cmd);
		if (cmd && (0 == strcmp(wrapped->cmd, cmd))) {
			VC_ELM_LOG_DBG("found action");
			found = wrapped;
			break;
		}
	}
	if (found) {
		char *tmp_buf = NULL;
		char *tmp_cmd = strdup(cmd);
		char *command = strtok_r(tmp_cmd, " ", &tmp_buf);
		char *param = strtok_r(NULL, "'", &tmp_buf);
		found->cmd = command;

		VC_ELM_LOG_DBG("unwrapping %s %s for %s", param1, param2, _get_ui_object_name(found->obj));
		found->unwrap_callback(found, param, param2);

		if (NULL != tmp_cmd)
			free(tmp_cmd);

		return EINA_TRUE;
	}

	return EINA_FALSE;
}

/* implementation */
static void __hash_entry_dummy_cb(void *entry)
{
	(void)entry;
}

static void __hash_entry_free_cb(void *entry)
{
	free(entry);
}

static void __hash_entry_stringshare_free_cb(void *entry)
{
	eina_stringshare_del(entry);
}

static void __hash_entry_eina_list_free_cb(void *entry)
{
	Eina_List *list = (Eina_List *)entry;
	Eina_List *l;
	void *data;

	EINA_LIST_FOREACH(list, l, data) {
		eina_stringshare_del(data);
		list = eina_list_remove_list(list, l);
	}
}

static void __widget_info_free_cb(void *entry)
{
	struct vc_elm_core_widget_info *info = entry;
	unsigned int idx;
	for (idx = 0; idx < info->actions_count; ++idx)
		eina_stringshare_del(info->actions[idx].name);
	free(info);
}

/**
 * @brief Function that starts the widgets tree traversal
 * @param[in] extra data to be passed
 */
static Eina_Bool __idle_enter(void *data);

/**
 * @brief Function that set's the internal window handlers of current app.
 * @param[in] extra data to be passed
 */
/*static Eina_Bool _delayed_window_load(void *data);*/

void _vc_elm_core_init()
{
	int ret;
	const char * tmp = tzplatform_mkpath(TZ_SYS_RO_SHARE, "locale/");
	bindtextdomain("voice-control-elm", tmp);
//	bindtextdomain("voice-control-elm", "/usr/share/locale/");

	g_widget_info_hash = eina_hash_string_djb2_new(__widget_info_free_cb);
	item_hint_map = eina_hash_pointer_new(__hash_entry_free_cb);
	item_command_map = eina_hash_pointer_new(__hash_entry_free_cb);
	item_custom_map = eina_hash_pointer_new(__hash_entry_free_cb);
	command_item_map = eina_hash_string_superfast_new(__hash_entry_free_cb);
	registered_item_map = eina_hash_string_superfast_new(__hash_entry_free_cb);

	g_config_action_map = eina_hash_string_superfast_new(__hash_entry_stringshare_free_cb);
	g_config_widget_map = eina_hash_string_superfast_new(__hash_entry_eina_list_free_cb);

	ret = _vc_elm_core_read_xml_data();
	g_view_changed = EINA_FALSE;
	VC_ELM_LOG_DBG("XML RETURNED %d", ret);
}

void _vc_elm_core_fini()
{
	eina_hash_free(g_widget_info_hash);
	g_widget_info_hash = NULL;

	eina_hash_free_buckets(registered_item_map);
	eina_hash_free(registered_item_map);
	registered_item_map = NULL;

	eina_hash_free(g_config_action_map);
	g_config_action_map = NULL;
	eina_hash_free(g_config_widget_map);
	g_config_widget_map = NULL;
	_vc_elm_core_destroy_xml_data();

#ifndef SRPOL_DEBUG
	_vc_elm_widget_wrapper_deinitialize();
#endif
}

void _vc_elm_core_load()
{
#ifndef SRPOL_DEBUG
	_vc_elm_widget_wrapper_set_show_tooltips_callback(__show_or_hide_tooltips_callback);
	_vc_elm_widget_wrapper_initialize();
#endif
}

Evas_Object *_vc_elm_core_get_evas_object(Elm_Object_Item *item)
{
	Elm_Widget_Item_Data *ret;
	ret = eo_data_scope_get(item, ELM_WIDGET_ITEM_CLASS);
	if (NULL != ret)
		return (Evas_Object *)(ret->view);
	else
		return NULL;
}

static Eina_List *__get_objects_of_visible_items(Evas_Object *parent, Elm_Object_Item *(*get_first)(const Evas_Object *obj), Elm_Object_Item *(*get_next)(const Elm_Object_Item *item))
{
	Eina_List *ret = NULL;
	Elm_Object_Item *item = get_first(parent);
	int x;
	int y;
	int w;
	int h;
	const char *item_hint = NULL;
	const char *item_command = NULL;
	struct Custom_Data *item_custom_date = NULL;

	if (item == NULL)
		return ret;

	evas_object_geometry_get(parent, &x, &y, &w, &h);
	do {
		int x_1;
		int y_1;
		int w_1;
		int h_1;
		Evas_Object *obj;
		const char *name;

		obj = _vc_elm_core_get_evas_object(item);
		if (!obj)
			continue;

		item_hint = eina_hash_find(item_hint_map, &item);
		item_command = eina_hash_find(item_command_map, &item);

		if (item_command != NULL) {
			if (item_hint != NULL)
				evas_object_data_set(obj, VC_ELM_HINT_DATA_KEY, item_hint);
			evas_object_data_set(obj, VC_ELM_CMD_DATA_KEY, item_command);
		}

		item_custom_date = eina_hash_find(item_custom_map, &item);

		if (item_custom_date != NULL) {
			evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_HINT_IMAGE_PATH), (const void *)item_custom_date->image_path);
			evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_POSITION_X), (void *)item_custom_date->pos_x);
			evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_POSITION_Y), (void *)item_custom_date->pos_y);
		}

		evas_object_geometry_get(obj, &x_1, &y_1, &w_1, &h_1);
		name = elm_widget_type_get(obj);
		if (NULL != name && NULL == eina_hash_find(registered_item_map, name) && NULL != eina_hash_find(g_config_widget_map, name)) {
			Eina_List *list2 = eina_hash_find(g_config_widget_map, name);
			VC_ELM_LOG_DBG("CORE LIST action size %u", eina_list_count(list2));
			_vc_elm_core_register_default_widget(name, EINA_TRUE, eina_hash_find(g_config_widget_map, name));
			eina_hash_add(registered_item_map, name, strdup("1"));
		}
		VC_ELM_LOG_DBG("have a visible item %d %d %d %d", x_1, y_1, w_1, h_1);
		if ((NULL == name) || (!strcmp("Elm_Layout", name)))
			evas_object_data_set(obj, "special_item", item);
		ret = eina_list_append(ret, obj);
	} while ((item = get_next(item)) != NULL);

	return ret;
}

static Eina_Bool __item_item_map_foreach(const Eina_Hash *hash, const void *key, void *data, void *fdata)
{
	Evas_Object *eo = NULL;
	const char *item_hint = NULL;
	struct Custom_Data *item_custom_date = NULL;
	R parent_dim;
	R item_dim;
	R out_dim;
	(void)hash;

	eo = _vc_elm_core_get_evas_object(data);
	if (NULL == eo)
		return EINA_TRUE;
	item_hint = eina_hash_find(item_hint_map, &data);
	eo = evas_object_smart_parent_get(evas_object_smart_parent_get(eo));
	if (NULL == eo)
		return EINA_TRUE;
	_R_set_from_efl(&parent_dim, evas_object_smart_parent_get(evas_object_smart_parent_get(evas_object_smart_parent_get(eo))));
	_R_set_from_efl(&item_dim, fdata);

	if (eo == fdata) {
		if (_R_intersection(&item_dim, &parent_dim, &out_dim) && (evas_object_visible_get(elm_widget_parent_widget_get(eo)))) {
			evas_object_data_set(fdata, VC_ELM_CMD_DATA_KEY, key);
			if (item_hint != NULL)
				evas_object_data_set(fdata, VC_ELM_HINT_DATA_KEY, item_hint);
			item_custom_date = eina_hash_find(item_custom_map, &data);

			if (item_custom_date != NULL) {
				evas_object_data_set(fdata, _vc_elm_get_data_key(VC_ELM_HINT_IMAGE_PATH), (const void *)item_custom_date->image_path);
				evas_object_data_set(fdata, _vc_elm_get_data_key(VC_ELM_POSITION_X), (void *)item_custom_date->pos_x);
				evas_object_data_set(fdata, _vc_elm_get_data_key(VC_ELM_POSITION_Y), (void *)item_custom_date->pos_y);
			}
		} else {
			evas_object_data_del(fdata, VC_ELM_CMD_DATA_KEY);
			evas_object_data_del(fdata, VC_ELM_HINT_DATA_KEY);
		}
		return EINA_FALSE;
	}
	return EINA_TRUE;
}

static void __remove_ctxpopup(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
	Eina_List *constant_list = NULL;
	const Eina_List *tmp_list = NULL;

	(void)data;
	(void)e;
	(void)event_info;
	constant_list = elm_widget_can_focus_child_list_get(eina_list_data_get(elm_widget_can_focus_child_list_get(obj)));
	tmp_list = constant_list;
	do {
		Evas_Object *ee = eina_list_data_get(tmp_list);
		eina_hash_foreach(command_item_map, __item_item_map_foreach, ee);
		evas_object_data_del(ee, VC_ELM_CMD_DATA_KEY);
		evas_object_data_del(ee, VC_ELM_HINT_DATA_KEY);
	} while ((tmp_list = eina_list_next(tmp_list)) != NULL);
}

static Eina_List *__get_ctxpopup_objects_of_visible_items(Evas_Object *widget)
{
	Eina_List *constant_list = NULL;
	Eina_List *ret = NULL;
	const Eina_List *tmp_list = NULL;
	constant_list = elm_widget_can_focus_child_list_get(eina_list_data_get(elm_widget_can_focus_child_list_get(widget)));
	evas_object_event_callback_add(widget, EVAS_CALLBACK_HIDE, __remove_ctxpopup, widget);

	VC_ELM_LOG_DBG("NUMBERS OF WIDGETS IN CTXPOPUP %d", eina_list_count(constant_list));
	tmp_list = constant_list;
	do {
		Evas_Object *ee = eina_list_data_get(tmp_list);
		eina_hash_foreach(command_item_map, __item_item_map_foreach, ee);
		if (evas_object_data_get(ee, VC_ELM_CMD_DATA_KEY) || evas_object_data_get(ee, VC_ELM_HINT_DATA_KEY))
			ret = eina_list_append(ret, (void *)ee);
	} while ((tmp_list = eina_list_next(tmp_list)) != NULL);

	return ret;
}

Elm_Object_Item *_vc_elm_core_get_visible_item(Evas_Object *parent, Elm_Object_Item *(*get_first)(const Evas_Object *obj, void *user_data), Elm_Object_Item *(*get_next)(const Elm_Object_Item *item, void *user_data), void *user_data)
{
	Elm_Object_Item *ret = NULL;
	void *usr_d = user_data;
	Elm_Object_Item *item = get_first(parent, usr_d);
	int x;
	int y;
	int w;
	int h;

	if (item == NULL)
		return ret;

	evas_object_geometry_get(parent, &x, &y, &w, &h);
	do {
		int x_1;
		int y_1;
		int w_1;
		int h_1;
		Evas_Object *obj;

		obj = _vc_elm_core_get_evas_object(item);
		if (!obj)
			continue;
		evas_object_geometry_get(obj, &x_1, &y_1, &w_1, &h_1);
		if (x_1 >= x && y_1 >= y && (x_1 + w_1) <= (x + w) && (y_1 + h_1) <= (y + h)) {
			VC_ELM_LOG_DBG("detected visible item");
			ret = item;
			return ret;
		}
	} while ((item = get_next(item, usr_d)) != NULL);

	return ret;
}

static void __elm_widget_foreach_in_tree(Evas_Object *widget, Eina_Bool(*cb)(Evas_Object *widget, Eina_List **data), Eina_List **data)
{
	Eina_Bool visible = evas_object_visible_get(widget);

	VC_ELM_LOG_DBG("IS visible %s %d", _get_ui_object_name(widget), visible);
	if (visible) {
		Eina_List *list = NULL;
		const Eina_List *constant_list = NULL;
		const Eina_List *l = NULL;
		Evas_Object *obj = NULL;
		const char *obj_name = NULL;
		struct vc_elm_core_widget_info *info = NULL;

		obj_name = _get_ui_object_name(widget);
		if (NULL == eina_hash_find(registered_item_map, obj_name) && NULL != eina_hash_find(g_config_widget_map, obj_name)) {
			Eina_List *list2 = eina_hash_find(g_config_widget_map, obj_name);
			VC_ELM_LOG_DBG("CORE LIST action size %u", eina_list_count(list2));
			_vc_elm_core_register_default_widget(obj_name, EINA_TRUE, eina_hash_find(g_config_widget_map, obj_name));
			if (NULL != obj_name)
				eina_hash_add(registered_item_map, obj_name, strdup("1"));
		}
		VC_ELM_LOG_DBG("cb %s (%p)", obj_name, (void*)widget);

		cb(widget, data);

		if (NULL != (info = eina_hash_find(g_widget_info_hash, obj_name)) && obj_name != NULL && NULL != info->get_subobjects_func) {
			constant_list = info->get_subobjects_func(widget, info->user_data);
		} else if (obj_name != NULL && (!strcmp("Elm_Button", obj_name) || !strcmp("Elm_Index", obj_name))) {
			/* We dont want to have a tooltip for elm_icon on button */
			/* We dont want to have tooltips for elm_index items */
			return;
		} else if (obj_name != NULL && !strcmp("Elm_List", obj_name)) {
			VC_ELM_LOG_DBG(":: %s", obj_name);
			if (NULL == eina_hash_find(registered_item_map, "elm_item") && NULL != eina_hash_find(g_config_widget_map, "Elm_List")) {
				_vc_elm_core_register_default_widget("elm_item", EINA_TRUE, NULL);
				eina_hash_add(registered_item_map, "elm_item", strdup("1"));
			}
			constant_list = __get_objects_of_visible_items(widget, &elm_list_first_item_get, &elm_list_item_next);
		} else if (obj_name != NULL && !strcmp("Elm_Ctxpopup", obj_name)) {
			VC_ELM_LOG_DBG(":: %s", obj_name);
			if (NULL == eina_hash_find(registered_item_map, "elm_item") && NULL != eina_hash_find(g_config_widget_map, "Elm_Ctxpopup")) {
				_vc_elm_core_register_default_widget("elm_item", EINA_TRUE, NULL);
				eina_hash_add(registered_item_map, "elm_item", strdup("1"));
			}
			constant_list = __get_ctxpopup_objects_of_visible_items(widget);
			_vc_elm_core_set_object_hint(widget, _VC_ELM("IDS_CANCEL"));

		} else if (obj_name != NULL && !strcmp("Elm_Genlist", obj_name)) {
			VC_ELM_LOG_DBG(":: %s", obj_name);
			if (NULL == eina_hash_find(registered_item_map, "elm_item") && NULL != eina_hash_find(g_config_widget_map, "Elm_Genlist")) {
				_vc_elm_core_register_default_widget("elm_item", EINA_TRUE, NULL);
				eina_hash_add(registered_item_map, "elm_item", strdup("1"));
			}
			list = __get_objects_of_visible_items(widget, &elm_genlist_first_item_get, &elm_genlist_item_next_get);
			constant_list = elm_widget_can_focus_child_list_get(widget);
			EINA_LIST_FOREACH(constant_list, l, obj) {
				if (NULL == eina_list_data_find(list, obj))
					list = eina_list_append(list, obj);
			}
		} else if (obj_name != NULL && !strcmp("Elm_Gengrid", obj_name)) {
			VC_ELM_LOG_DBG(":: %s", obj_name);
			if (NULL == eina_hash_find(registered_item_map, "elm_item") && NULL != eina_hash_find(g_config_widget_map, "Elm_Gengrid")) {
				_vc_elm_core_register_default_widget("elm_item", EINA_TRUE, NULL);
				eina_hash_add(registered_item_map, "elm_item", strdup("1"));
			}
			list = __get_objects_of_visible_items(widget, &elm_gengrid_first_item_get, &elm_gengrid_item_next_get);
			constant_list = elm_widget_can_focus_child_list_get(widget);
			EINA_LIST_FOREACH(constant_list, l, obj) {
				if (NULL == eina_list_data_find(list, obj))
					list = eina_list_append(list, obj);
			}
		} else if (obj_name != NULL && !strcmp("Elm_Toolbar", obj_name)) {
			VC_ELM_LOG_DBG(":: %s", obj_name);
			if (NULL == eina_hash_find(registered_item_map, "elm_item") && NULL != eina_hash_find(g_config_widget_map, "Elm_Toolbar")) {
				_vc_elm_core_register_default_widget("elm_item", EINA_TRUE, NULL);
				eina_hash_add(registered_item_map, "elm_item", strdup("1"));
			}
			list = __get_objects_of_visible_items(widget, &elm_toolbar_first_item_get, &elm_toolbar_item_next_get);
		} else if (obj_name != NULL && !strcmp("Elm_Naviframe", obj_name)) {
			VC_ELM_LOG_DBG(":: %s", obj_name);
			list = eina_list_append(list, _vc_elm_core_get_evas_object(elm_naviframe_top_item_get(widget)));
		} else {
			constant_list = elm_widget_can_focus_child_list_get(widget);
		}

		if (list)
			constant_list = list;

		EINA_LIST_FOREACH(constant_list, l, obj) {
			const char *current_name = _get_ui_object_name(obj);

			VC_ELM_LOG_DBG("calling %p %s", (void*)obj, current_name);

			if ((current_name != NULL) && ((0 == strcmp(current_name, "Elm_Inwin")) || (0 == strcmp(current_name, "Elm_Popup")) || ((0 == strcmp(current_name, "Elm_Ctxpopup") && (evas_object_visible_get(obj)))))) {
				/*overlaying widget found, remove other widgets found,
				 traverse it's subtree and return*/
				VC_ELM_LOG_INFO("overlaying widget: found");

				if (data && (*data)) {
					eina_list_free(*data);
					*data = NULL;
				}

				__elm_widget_foreach_in_tree(obj, cb, data);

				VC_ELM_LOG_INFO("overlaying widget: subtree finished");
				return;
			} else {
				/*continue traversing other subtrees*/
				__elm_widget_foreach_in_tree(obj, cb, data);
			}
		}
		if (list)
			eina_list_free(list);
	} else {
		VC_ELM_LOG_DBG("not visible");
	}
}

static int __is_hiding_widget(Evas_Object *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)
{
	Evas_Object *above_obj;
	Evas_Coord my_x;
	Evas_Coord my_y;
	Evas_Coord my_w;
	Evas_Coord my_h;

	above_obj = evas_object_above_get(obj);
	if ((above_obj == NULL) || (obj == above_obj))
		return 0;

	evas_object_geometry_get(above_obj, &my_x, &my_y, &my_w, &my_h);

	if (strstr(evas_object_type_get(above_obj), "Elm") && !strstr(evas_object_type_get(above_obj), "Elm_Win") && evas_object_visible_get(above_obj) && ((my_x >= 0) && (my_y >= 0) && (my_w > 0) && (my_h > 0))) {
		if ((my_x <= x) && (my_y <= y) && ((my_x + my_w) >= (x + w)) && ((my_y + my_h) >= (y + h)))
			return 1;
	}

	return __is_hiding_widget(above_obj, x, y, w, h);
}

static int __is_hidden_widget(Evas_Object *obj)
{
	Evas_Coord x;
	Evas_Coord y;
	Evas_Coord w;
	Evas_Coord h;

	if (obj) {
		evas_object_geometry_get(obj, &x, &y, &w, &h);
		return __is_hiding_widget(obj, x, y, w, h);
	} else {
		return 0;
	}
}

static Eina_Bool __elm_widget_foreach_to_list_add(Evas_Object *widget, Eina_List **list)
{
	const char *obj_name = _get_ui_object_name(widget);
	Evas_Object *parent_obj = elm_object_parent_widget_get(widget);
	const char *parent_obj_name = _get_ui_object_name(parent_obj);
	Evas_Object *parents_parent_obj = elm_object_parent_widget_get(parent_obj);
	const char *parents_parent_obj_name = _get_ui_object_name(parents_parent_obj);

	assert(list);

	obj_name = eina_stringshare_add(obj_name);
	parent_obj_name = eina_stringshare_add(parent_obj_name);
	parents_parent_obj_name = eina_stringshare_add(parents_parent_obj_name);
	VC_ELM_LOG_DBG("Widget: %s, parent: %s", obj_name, parent_obj_name);

	if (obj_name) {
		if ((!strcmp("Elm_Inwin", obj_name)) || (!strcmp("Elm_Popup", obj_name)) || (!strcmp("Elm_Ctxpopup", obj_name))) {
			if (*list) {
				*list = eina_list_free(*list);
			}
		} else if ((!strcmp("Elm_Icon", obj_name))) {
			if ((NULL != parent_obj_name && !strcmp(parent_obj_name, "Elm_Genlist")) && (NULL != parents_parent_obj_name && !strcmp(parents_parent_obj_name, "Elm_Fileselector")))
				return EINA_FALSE;
		} else if ((!strcmp("Elm_Entry", obj_name))) {
			if (NULL != parent_obj && NULL != parent_obj_name && !strcmp(parent_obj_name, "Elm_Fileselector")) {
				return EINA_FALSE;
			}
		}
	}

	if (__is_hidden_widget(widget))
		return EINA_TRUE;

	*list = eina_list_append(*list, widget);
	return EINA_TRUE;
}

Eina_List *_vc_elm_core_find_all_visible_objects()
{
	Eina_List *ret = NULL;
	assert(!!g_default_window);
	if (!g_default_window)
		return NULL;
	__elm_widget_foreach_in_tree(g_default_window, __elm_widget_foreach_to_list_add, &ret);
	return ret;
}

/**
 * @brief Internal function that starts page analysis and tooltip showing
 */
#ifndef SRPOL_DEBUG
static
#endif
void _show_tooltips()
{
	Eina_List *_l;
	Evas_Object *obj = NULL;
	Evas_Object *parent = NULL;
	struct vc_elm_core_widget_info *info = NULL;
	const char *obj_name = NULL;
	const char *parent_obj_name = NULL;
	Evas_Coord x;
	Evas_Coord y;
	Evas_Coord w;
	Evas_Coord h;
	Evas_Coord x_p;
	Evas_Coord y_p;
	Evas_Coord w_p;
	Evas_Coord h_p;

	__idle_enter(NULL);

	VC_ELM_LOG_DBG("show_tooltips");
	EINA_LIST_FOREACH(g_current_ui_objects, _l, obj) {
		parent = elm_object_parent_widget_get(obj);
		info = NULL;
		obj_name = _get_ui_object_name(obj);
		parent_obj_name = _get_ui_object_name(parent);

		if ((!obj_name && evas_object_data_get(obj, "special_item")) || (!strcmp(obj_name, "Elm_Layout") && evas_object_data_get(obj, "special_item")))
			obj_name = eina_stringshare_add("evc-item");

		if (!obj_name) {
			VC_ELM_LOG_DBG("[TOOLTIP] Widget name is null");
			continue;
		} else if (!strcmp(obj_name, "evc-item")) {
			parent = elm_object_parent_widget_get(obj);
			parent_obj_name = _get_ui_object_name(parent);

			while ((NULL != parent) && (NULL != parent_obj_name) && (0 != strcmp(parent_obj_name, "Elm_Genlist") && 0 != strcmp(parent_obj_name, "Elm_List") && 0 != strcmp(parent_obj_name, "Elm_Gengrid") && 0 != strcmp(parent_obj_name, "Elm_Ctxpopup") && 0 != strcmp(parent_obj_name, "Elm_Toolbar"))) {
				parent = elm_object_parent_widget_get(parent);

				if (NULL != parent)
					parent_obj_name = _get_ui_object_name(parent);
			}

			if (NULL == parent)
				continue;

			parent_obj_name = _get_ui_object_name(parent);

			if ((NULL != parent_obj_name) && (0 == strcmp(parent_obj_name, "Elm_Genlist") || 0 == strcmp(parent_obj_name, "Elm_List") || 0 == strcmp(parent_obj_name, "Elm_Gengrid") || 0 == strcmp(parent_obj_name, "Elm_Toolbar"))) {
				evas_object_geometry_get(obj, &x, &y, &w, &h);
				evas_object_geometry_get(parent, &x_p, &y_p, &w_p, &h_p);

				if ((y < y_p - Y_VISIBILITY_TOLERANCE) || (y + h > y_p + h_p + Y_VISIBILITY_TOLERANCE) || (x < x_p - X_VISIBILITY_TOLERANCE) || (x + w > y_p + w_p + X_VISIBILITY_TOLERANCE))
					continue;
			}
		} else if (NULL == (info = eina_hash_find(g_widget_info_hash, obj_name))) {
			VC_ELM_LOG_DBG("[TOOLTIP] Widget type '%s' not supported", obj_name);
			continue;
		} else if (!strcmp(obj_name, "Elm_Naviframe")) {
			VC_ELM_LOG_DBG("[TOOLTIP] No tooltip for %s", obj_name);
			continue;
		} else if ((NULL != parent_obj_name) && (0 == strcmp(parent_obj_name, "Elm_Genlist") || 0 == strcmp(parent_obj_name, "Elm_List") || 0 == strcmp(parent_obj_name, "Elm_Gengrid") || 0 == strcmp(parent_obj_name, "Elm_Toolbar"))) {
			evas_object_geometry_get(obj, &x, &y, &w, &h);
			evas_object_geometry_get(parent, &x_p, &y_p, &w_p, &h_p);

			if ((y < y_p - Y_VISIBILITY_TOLERANCE) || (y + h > y_p + h_p + Y_VISIBILITY_TOLERANCE) || (x < x_p - X_VISIBILITY_TOLERANCE) || (x + w > y_p + w_p + X_VISIBILITY_TOLERANCE))
				continue;
		} else {
			parent = elm_object_parent_widget_get(obj);

			if (NULL == parent)
				continue;

			parent_obj_name = _get_ui_object_name(parent);

			evas_object_geometry_get(obj, &x, &y, &w, &h);
			evas_object_geometry_get(parent, &x_p, &y_p, &w_p, &h_p);

			VC_ELM_LOG_DBG("item %d %d %d %d %s %d %d %d %d", x, y, w, h, parent_obj_name, x_p, y_p, w_p, h_p);

			if (!((y + Y_VISIBILITY_TOLERANCE > y_p) || (y_p + h_p + Y_VISIBILITY_TOLERANCE > y + h) || (x + X_VISIBILITY_TOLERANCE > x_p) || (y_p + w_p + X_VISIBILITY_TOLERANCE > x + w)))
				continue;
		}

		VC_ELM_LOG_DBG("[TOOLTIP] the tooltip for %s", obj_name);
		_vc_elm_tooltips_show_tooltip(obj, evas_object_data_get(obj, VC_ELM_HINT_DATA_KEY));
	}

	_vc_elm_relayout_and_show_tooltips();
	g_view_changed = EINA_FALSE;
}

struct vc_elm_core_widget_info *_vc_elm_core_register_widget(const char *widget_name, vc_elm_get_subobjects_cb get_subobjects_func, vc_elm_command_filter_cb is_filtered_func, void *user_data)
{
	struct vc_elm_core_widget_info *info = NULL;
	void *found = eina_hash_find(g_widget_info_hash, widget_name);
	if (found) {
		VC_ELM_LOG_ERR("Widget already registered: %s", widget_name);
	} else {
		info = malloc(sizeof(struct vc_elm_core_widget_info));
		if (info != NULL) {
			memset(info, 0, sizeof(*info));
			info->name = eina_stringshare_add(widget_name);
			info->get_subobjects_func = get_subobjects_func;
			info->is_filtered_func = is_filtered_func;
			info->actions = NULL;
			info->actions_count = 0;
			info->user_data = user_data;
			if (eina_hash_add(g_widget_info_hash, info->name, info))
				VC_ELM_LOG_INFO("Registered widget: %s", widget_name);
			else
				VC_ELM_LOG_ERR("Failed to register widget: %s", widget_name);
		}
	}
	return info;
}

void _vc_elm_core_register_action(struct vc_elm_core_widget_info *info, const char *action_name, void *data, vc_elm_action_activator_cb action_activator_func)
{
	unsigned int idx = 0;
	if (!info) {
		VC_ELM_LOG_ERR("widget handle required");
		return;
	}

	idx = info->actions_count;
	info->actions_count++;

	info->actions = realloc(info->actions, sizeof(struct vc_elm_core_action_info) * info->actions_count);
	if (info->actions != NULL) {
		info->actions[idx].name = eina_stringshare_add(action_name);
		info->actions[idx].data = data;
		info->actions[idx].action_activator_func = action_activator_func;

		VC_ELM_LOG_DBG("Registered widget in VC_ELM (%s, %s)", info->name, action_name);
	}
}

static void __vc_add_commands()
{
	Eina_List *_l;
	Evas_Object *obj;
	size_t idx;
	unsigned int registered;
	Elm_Object_Item *item = NULL;
	Evas_Object *parent;
	Evas_Coord x;
	Evas_Coord y;
	Evas_Coord w;
	Evas_Coord h;
	Evas_Coord x_p;
	Evas_Coord y_p;
	Evas_Coord w_p;
	Evas_Coord h_p;

	_vc_elm_get_text_domain(&g_app_domain);
	VC_ELM_LOG_DBG("app domain - %s", g_app_domain);
	{
		const Eina_List *l;
		struct Wrapped_Command *wrapped;
		EINA_LIST_FOREACH(g_wrapped_commands, l, wrapped) {
			free(wrapped);
		}
		eina_list_free(g_wrapped_commands);
		g_wrapped_commands = NULL;
	}

	EINA_LIST_FOREACH(g_current_ui_objects, _l, obj) {
		struct vc_elm_core_widget_info *info = NULL;
		const char *obj_name = _get_ui_object_name(obj);
		char *command = NULL;
		char *comm = NULL;
		int ret;
		obj_name = eina_stringshare_add(obj_name);
		registered = 0;
		if (obj_name)
			VC_ELM_LOG_DBG("Adding command for %s", obj_name);
		if ((!obj_name && evas_object_data_get(obj, "special_item")) || (!strcmp(obj_name, "Elm_Layout") && evas_object_data_get(obj, "special_item")))
			obj_name = eina_stringshare_add("evc-item");
		if (!obj_name) {
			VC_ELM_LOG_DBG("Widget '%p' has no type specified", obj_name);
			continue;
		}
		if (NULL == (info = eina_hash_find(g_widget_info_hash, obj_name))) {
			VC_ELM_LOG_DBG("Widget type '%s' not supported", obj_name);
			continue;
		}

		command = evas_object_data_get(obj, VC_ELM_CMD_DATA_KEY);
		if (!command)
			continue;

		for (idx = 0; idx < info->actions_count; ++idx) {
			struct vc_elm_core_action_info *action = info->actions + idx;
			if ((info->is_filtered_func) && (info->is_filtered_func(obj, _VC_ELM(action->name), info->user_data))) {
				VC_ELM_LOG_DBG("Filtered command [%s, %s, %s]", obj_name, command, action->name);
				continue;
			}
			VC_ELM_LOG_DBG("Creating command [%s, %s, %s]", obj_name, command, action->name);

			parent = elm_object_parent_widget_get(obj);

			if (parent != NULL) {
				if (0 == strcmp(_get_ui_object_name(parent), "Elm_Genlist")) {
					item = elm_genlist_first_item_get(parent);

					do {
						evas_object_geometry_get(obj, &x, &y, &w, &h);
						evas_object_geometry_get(_vc_elm_core_get_evas_object(item), &x_p, &y_p, &w_p, &h_p);

						if ((x_p + w_p >= x + w) && (y_p + h_p >= y + h) && (y_p <= y))
							break;
					} while ((item = elm_genlist_item_next_get(item)) != NULL);
				}
			}

			comm = NULL;
			if (_VC_ELM(action->name) == NULL || !strcmp(_VC_ELM(action->name), ""))
				ret = asprintf(&comm, "%s", _APP(command));
			else
				ret = asprintf(&comm, "%s %s", _APP(command), _VC_ELM(action->name));

			if (-1 == ret) {
				VC_ELM_LOG_ERR("Error translating command: %s", command);
				continue;
			}

			_vc_elm_widget_wrapper_add_command(comm, NULL);

			{
				struct Wrapped_Command *cmd = NULL;
				cmd = malloc(sizeof(struct Wrapped_Command));
				if (cmd != NULL) {
					memset(cmd, 0, sizeof(*cmd));
					cmd->cmd = eina_stringshare_add(comm);
					cmd->obj = obj;
					cmd->data = info;
					cmd->unwrap_callback = &__unwrap_universal_item_command;
					cmd->parent_item = item;
					g_wrapped_commands = eina_list_append(g_wrapped_commands, cmd);
				}
			}

			if (NULL != comm)
				free(comm);
			++registered;
		}

		if (registered == 0)
			evas_object_data_del(obj, VC_ELM_HINT_DATA_KEY);
		eina_stringshare_del(obj_name);
	}

	_vc_elm_widget_wrapper_commit_commands(&__result_cb, NULL);
}

#ifndef SRPOL_DEBUG
static
#endif
void _hide_tooltips()
{
	VC_ELM_LOG_DBG("hide_tooltips");
	_vc_elm_turn_off_tooltips();
}

static int __result_cb(const char *cmd, const char *param1, const char *param2, void *user_data)
{
	(void)user_data;
	_hide_tooltips();

	VC_ELM_LOG_DBG("Got result from VC %s %s %s", cmd, param1, param2);

	if (!_recognize_command(cmd, param1, NULL))
		VC_ELM_LOG_DBG("Command not found");
	return 0;
}

Eina_Bool _vc_elm_core_equal_actions(const char *action1, const char *action2)
{
	if (!action1 || !action2)
		return action1 == action2;
	else
		return !strcmp(action1, action2);
}

static void __activate_cb(void *data, Evas_Object *obj, void *event_info)
{
	struct Unwrapped_Command *unwr = (struct Unwrapped_Command *)data;
	Evas_Object *object;
	const struct vc_elm_core_widget_info *info;
	unsigned int idx = 0;

	(void)event_info;
	(void)obj;

	if (NULL != unwr) {
		object = unwr->wrap->obj;
		info = (const struct vc_elm_core_widget_info*)unwr->wrap->data;

		LOGI("activate_cb activated");
		VC_ELM_LOG_DBG("_unwrap_widget_command with params: %s %s %s", unwr->action, unwr->action, unwr->wrap->cmd);

		for (idx = 0; idx < info->actions_count; ++idx) {
			if ((!unwr->action && (_vc_elm_core_equal_actions("", _VC_ELM(info->actions[idx].name)))) || _vc_elm_core_equal_actions(unwr->action, _VC_ELM(info->actions[idx].name))) {
				VC_ELM_LOG_DBG("activating action %s %s", unwr->action, unwr->param);
				info->actions[idx].action_activator_func(object, info->actions[idx].data, unwr->action);
				break;
			}
		}

		if (unwr->action)
			free(unwr->action);
		if (unwr->param)
			free(unwr->param);
		free(unwr);
		return;
	}
	return;
}

static void __activate_invisible_item_cb(void *data, Evas_Object *obj, void *event_info)
{
	if (NULL != obj)
		evas_object_smart_callback_del(obj, "scroll,anim,stop", __activate_invisible_item_cb);

	LOGI("_activate_universal_item_cb	activated");
	__activate_cb(data, obj, event_info);

	return;
}

static void __dismissed_cb(void *data, Evas_Object *obj, void *event_info)
{
	(void)data;
	(void)event_info;

	if (NULL != obj)
		evas_object_smart_callback_del(obj, "dismissed", __dismissed_cb);

	elm_ctxpopup_dismiss(obj);
	elm_ctxpopup_clear(obj);
	evas_object_del(obj);

}

static void __unwrap_universal_item_command(struct Wrapped_Command *wrapper, const char *action, const char *param)
{
	struct Unwrapped_Command *unwr = (struct Unwrapped_Command *)calloc(1, sizeof(struct Unwrapped_Command));
	Elm_Object_Item *item = (Elm_Object_Item *)eina_hash_find(command_item_map, wrapper->cmd);
	Evas_Object *parent = NULL;
	Elm_Object_Item *parent_item = NULL;
	Evas_Coord x;
	Evas_Coord y;
	Evas_Coord w;
	Evas_Coord h;
	Evas_Coord x_p;
	Evas_Coord y_p;
	Evas_Coord w_p;
	Evas_Coord  h_p;

	if (NULL == unwr) {
		VC_ELM_LOG_ERR("Fail to allocate memory");
		return;
	}

	unwr->wrap = wrapper;
	unwr->action = (action) ? strdup(action) : NULL;
	unwr->param = (param) ? strdup(param) : NULL;
	VC_ELM_LOG_DBG("__unwrap_universal_item_command with params: %p %p %s %s", (void *)wrapper->obj, (void *)item, action, param);

	if (NULL != item) {
		parent = elm_object_parent_widget_get(_vc_elm_core_get_evas_object(item));

		while (NULL != parent) {
			if (0 == strcmp(_get_ui_object_name(parent), "Elm_Genlist")) {
				evas_object_geometry_get(_vc_elm_core_get_evas_object(item), &x, &y, &w, &h);
				evas_object_geometry_get(parent, &x_p, &y_p, &w_p, &h_p);
				if (y > h_p || y < y_p) {
					evas_object_smart_callback_add(parent, "scroll,anim,stop", __activate_invisible_item_cb, (void*)unwr);
					elm_genlist_item_bring_in(item, ELM_GENLIST_ITEM_SCROLLTO_MIDDLE);
				} else {
					__activate_cb((void*)unwr, NULL, NULL);
				}
				return;
			} else if (0 == strcmp(_get_ui_object_name(parent), "Elm_List")) {
				elm_list_item_show(item);
				break;
			} else if (0 == strcmp(_get_ui_object_name(parent), "Elm_Gengrid")) {
				elm_gengrid_item_show(item, ELM_GENGRID_ITEM_SCROLLTO_MIDDLE);
				break;
			} else if (0 == strcmp(_get_ui_object_name(parent), "Elm_Toolbar")) {
				elm_toolbar_item_show(item, ELM_TOOLBAR_ITEM_SCROLLTO_IN);
				break;
			} else if (0 == strcmp(_get_ui_object_name(parent), "Elm_Ctxpopup")) {
				/*no way to bring item in, try clicking it*/
				evas_object_smart_callback_add(parent, "dismissed", __dismissed_cb, NULL);
				__activate_cb((void*)unwr, NULL, NULL);
				return;
			} else {
				parent = elm_object_parent_widget_get(parent);
			}
		}
	}

	parent_item = unwr->wrap->parent_item;
	if (parent_item != NULL) {

		evas_object_geometry_get(_vc_elm_core_get_evas_object(parent_item), &x, &y, &w, &h);
		evas_object_geometry_get(elm_object_parent_widget_get(_vc_elm_core_get_evas_object(parent_item)), &x_p, &y_p, &w_p, &h_p);

		if (y > h_p || y < y_p) {
			evas_object_smart_callback_add(elm_object_parent_widget_get(_vc_elm_core_get_evas_object(parent_item)), "scroll,anim,stop", __activate_invisible_item_cb, (void*)unwr);
			elm_genlist_item_bring_in(parent_item, ELM_GENLIST_ITEM_SCROLLTO_MIDDLE);
			return;
		}
	}

	__activate_cb((void *)unwr, NULL, NULL);
}

static void __object_del_callback(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
	(void)e;
	(void)event_info;
	eina_stringshare_del((char *)data);
	evas_object_data_del(obj, VC_ELM_CMD_DATA_KEY);
	ui_objects_list = eina_list_remove(ui_objects_list, obj);
}

static void __item__object_del_callback(void *data, Evas_Object *obj, void *event_info)
{
	struct Custom_Data *cdata;
	Elm_Object_Item *obj_item = (Elm_Object_Item *)event_info;

	(void)data;
	(void)obj;

	eina_hash_free_cb_set(item_hint_map, __hash_entry_dummy_cb);
	eina_hash_free_cb_set(item_command_map, __hash_entry_dummy_cb);
	eina_hash_free_cb_set(item_custom_map, __hash_entry_dummy_cb);

	eina_stringshare_del((char *)eina_hash_find(item_hint_map, &obj_item));
	eina_stringshare_del((char *)eina_hash_find(item_command_map, &obj_item));

	cdata = (struct Custom_Data *)eina_hash_find(item_custom_map, &obj_item);
	free(cdata);

	eina_hash_del(item_hint_map, &obj_item, NULL);
	eina_hash_del(item_command_map, &obj_item, NULL);
	eina_hash_del(item_custom_map, &obj_item, NULL);

	eina_hash_free_cb_set(item_hint_map, __hash_entry_free_cb);
	eina_hash_free_cb_set(item_command_map, __hash_entry_free_cb);
	eina_hash_free_cb_set(item_custom_map, __hash_entry_free_cb);
}

Eina_Bool _vc_elm_core_set_object_command(Evas_Object *obj, const char *_command)
{
	const char *command = eina_stringshare_add(_command);
	evas_object_data_set(obj, VC_ELM_CMD_DATA_KEY, command);
	if (NULL == eina_list_data_find(ui_objects_list, obj))
		ui_objects_list = eina_list_append(ui_objects_list, obj);
	VC_ELM_LOG_DBG("added new item %d %p", eina_list_count(ui_objects_list), (void*)obj);
	evas_object_event_callback_add(obj, EVAS_CALLBACK_DEL, __object_del_callback, command);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_unset_object_command(Evas_Object *obj)
{
	evas_object_data_del(obj, VC_ELM_CMD_DATA_KEY);
	ui_objects_list = eina_list_remove(ui_objects_list, obj);
	evas_object_event_callback_del(obj, EVAS_CALLBACK_DEL, __object_del_callback);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_object_hint(Evas_Object *obj, const char *_hint)
{
	if (evas_object_data_get(obj, VC_ELM_CMD_DATA_KEY) != NULL) {
		const char *hint = eina_stringshare_add(_hint);
		evas_object_data_set(obj, VC_ELM_HINT_DATA_KEY, hint);
		return EINA_TRUE;
	}
	return EINA_FALSE;
}

Eina_Bool _vc_elm_core_unset_object_hint(Evas_Object *obj)
{
	evas_object_data_del(obj, VC_ELM_HINT_DATA_KEY);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_item_object_command(Elm_Object_Item *obj, const char *_command)
{
	const char *command = eina_stringshare_add(_command);
	if (NULL == command)
		return EINA_FALSE;
	eina_hash_add(item_command_map, &obj, command);
	eina_hash_add(command_item_map, command, obj);
	elm_object_item_del_cb_set(obj, __item__object_del_callback);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_unset_item_object_command(Elm_Object_Item *obj)
{
	eina_hash_free_cb_set(item_command_map, __hash_entry_dummy_cb);

	eina_stringshare_del((char *)eina_hash_find(item_command_map, &obj));
	eina_hash_del(item_command_map, &obj, NULL);

	eina_hash_free_cb_set(item_command_map, __hash_entry_free_cb);

	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_item_object_hint(Elm_Object_Item *obj, const char *_hint)
{
	if (eina_hash_find(item_command_map, &obj) != NULL) {
		const char *hint = eina_stringshare_add(_hint);
		eina_hash_add(item_hint_map, &obj, hint);
		return EINA_TRUE;
	}
	return EINA_FALSE;
}

Eina_Bool _vc_elm_core_unset_item_object_hint(Elm_Object_Item *obj)
{
	eina_hash_free_cb_set(item_hint_map, __hash_entry_dummy_cb);

	eina_stringshare_del((char *)eina_hash_find(item_hint_map, &obj));
	eina_hash_del(item_hint_map, &obj, NULL);

	eina_hash_free_cb_set(item_hint_map, __hash_entry_free_cb);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_object_custom_hint(Evas_Object *obj, const char *image_path, int pos_x, int pos_y)
{
	if (NULL == obj) {
		VC_ELM_LOG_ERR("Invalid Evas_Object parameter detected!");
		return EINA_FALSE;
	}
	evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_HINT_IMAGE_PATH), (const void *)image_path);

	if (pos_x >= 0)
		evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_POSITION_X), (void *)(pos_x + 1));
	else
		evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_POSITION_X), (void *)(pos_x - 1));

	if (pos_y >= 0)
		evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_POSITION_Y), (void *)(pos_y + 1));
	else
		evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_POSITION_Y), (void *)(pos_y - 1));
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_get_object_custom_hint(Evas_Object *obj, const char **image_path, int *pos_x, int *pos_y)
{
	int acc;
	if (NULL == obj) {
		VC_ELM_LOG_ERR("Invalid Evas_Object parameter detected!");
		return EINA_FALSE;
	}
	*image_path = (const char *)evas_object_data_get(obj, _vc_elm_get_data_key(VC_ELM_HINT_IMAGE_PATH));

	acc = (int)(evas_object_data_get(obj, _vc_elm_get_data_key(VC_ELM_POSITION_X)));
	if (acc > 0)
		*pos_x = acc - 1;
	else
		*pos_x = acc + 1;

	acc = (int)evas_object_data_get(obj, _vc_elm_get_data_key(VC_ELM_POSITION_Y));
	if (acc > 0)
		*pos_y = acc - 1;
	else
		*pos_y = acc + 1;
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_item_object_custom_hint(Elm_Object_Item *obj, const char *image_path, int pos_x, int pos_y)
{
	struct Custom_Data *cdata;
	if (NULL == obj) {
		VC_ELM_LOG_ERR("Invalid Elm_Object_Item parameter detected!");
		return EINA_FALSE;
	}
	cdata = eina_hash_find(item_custom_map, &obj);
	if (NULL == cdata) {
		cdata = (struct Custom_Data *)calloc(1, sizeof(struct Custom_Data));
		if (NULL == cdata) {
			VC_ELM_LOG_ERR("Fail to allocate memory");
			return EINA_FALSE;
		}
		cdata->image_path = image_path;
		cdata->pos_x = pos_x;
		cdata->pos_y = pos_y;
		eina_hash_add(item_custom_map, &obj, cdata);
	} else {
		cdata->image_path = image_path;
		cdata->pos_x = pos_x;
		cdata->pos_y = pos_y;
	}

	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_get_item_object_custom_hint(Elm_Object_Item *obj, const char **image_path, int *pos_x, int *pos_y)
{
	struct Custom_Data *cdata;
	if (NULL == obj) {
		VC_ELM_LOG_ERR("Invalid Elm_Object_Item parameter detected!");
		return EINA_FALSE;
	}
	cdata = eina_hash_find(item_custom_map, &obj);
	if (NULL != cdata) {
		*image_path = (const char *)cdata->image_path;
		*pos_x = (int)cdata->pos_x;
		*pos_y = (int)cdata->pos_y;
	}

	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_unset_item_object_custom_hint(Elm_Object_Item *obj)
{
	struct Custom_Data *cdata;
	if (NULL == obj) {
		VC_ELM_LOG_ERR("Invalid Elm_Object_Item parameter detected!");
		return EINA_FALSE;
	}
	cdata = eina_hash_find(item_custom_map, &obj);
	if (NULL == cdata) {
		eina_hash_del(item_custom_map, &obj, cdata);
		free(cdata);
	}

	return EINA_TRUE;
}

const char *_vc_elm_core_get_object_hint(const Evas_Object *obj)
{
	const char *hint = evas_object_data_get(obj, VC_ELM_HINT_DATA_KEY);
	return hint;
}

Eina_Bool _vc_elm_core_set_object_hint_fixed_possition(Evas_Object *obj, int x, int y)
{
	evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_FIXED_X), (void *)x);
	evas_object_data_set(obj, _vc_elm_get_data_key(VC_ELM_FIXED_Y), (void *)y);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_get_object_hint_fixed_possition(Evas_Object *obj, int *x, int *y)
{
	*x = (int)evas_object_data_get(obj, _vc_elm_get_data_key(VC_ELM_FIXED_X));
	*y = (int)evas_object_data_get(obj, _vc_elm_get_data_key(VC_ELM_FIXED_Y));
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_del_object_hint_fixed_possition(Evas_Object *obj)
{
	evas_object_data_del(obj, _vc_elm_get_data_key(VC_ELM_FIXED_X));
	evas_object_data_del(obj, _vc_elm_get_data_key(VC_ELM_FIXED_Y));
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_object_hint_direction(Evas_Object *obj, vc_elm_direction_e direction)
{
	evas_object_data_set(obj, VC_ELM_DIRECTION, (void *)(direction + 1));
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_get_object_hint_direction(Evas_Object *obj, vc_elm_direction_e *direction)
{
	*direction = ((vc_elm_direction_e)evas_object_data_get(obj, VC_ELM_DIRECTION)) - 1;
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_del_object_hint_direction(Evas_Object *obj)
{
	evas_object_data_del(obj, VC_ELM_DIRECTION);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_set_sub_item_hint_direction(Evas_Object *obj, vc_elm_direction_e direction)
{
	evas_object_data_set(obj, VC_ELM_SUB_ITEM_DIRECTION, (void *)(direction + 1));
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_get_sub_item_hint_direction(Evas_Object *obj, vc_elm_direction_e *direction)
{
	*direction = ((vc_elm_direction_e)evas_object_data_get(obj, VC_ELM_SUB_ITEM_DIRECTION)) - 1;
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_del_sub_item_hint_direction(Evas_Object *obj)
{
	evas_object_data_del(obj, VC_ELM_SUB_ITEM_DIRECTION);
	return EINA_TRUE;
}

Eina_Bool _vc_elm_core_enable_name_autogen(Eina_Bool ag)
{
	g_hints_autogenerated = ag;
	return EINA_TRUE;
}

static void __show_or_hide_tooltips_callback(bool show_or_hide)
{
	VC_ELM_LOG_DBG("tooltips %d", show_or_hide);
	g_tooltips_displayed = show_or_hide;
	if (show_or_hide)
		_show_tooltips();
	else
		_hide_tooltips();
}

static Eina_Bool on_idle(void *data)
{
	int ret = -1;
	(void)data;
	VC_ELM_LOG_DBG("End Of View Transformation, tooltip displayed (%d), changed (%d)", g_tooltips_displayed, g_view_changed);

	if (g_animation_view_idler) {
		ecore_timer_del(g_animation_view_idler);
		g_animation_view_idler = NULL;
	}

	if (g_tooltips_displayed) {

		if (g_view_changed){
			_vc_elm_widget_wrapper_clear_commands();
			/*_show_tooltips();*/
			ret = _vc_elm_widget_wrapper_cancel();
			if (0 != ret) {
				VC_ELM_LOG_ERR("Error to cancel widget");
			}
			g_view_changed = EINA_FALSE;
		} else if (_vc_elm_relayout_changed()) {
			_hide_tooltips();
			ecore_main_loop_iterate();
			_vc_elm_widget_wrapper_clear_commands();
			_show_tooltips();
		}
	}
	return EINA_FALSE;
}

static void __idle_changed(Ecore_Evas *ee)
{
	(void)ee;
	VC_ELM_LOG_DBG("View changed");
	if (g_tooltips_displayed && g_view_changed){
		_hide_tooltips();
	}
	if (g_animation_view_idler) {
		ecore_timer_del(g_animation_view_idler);
		g_animation_view_idler = NULL;
	}
	g_animation_view_idler = ecore_timer_add(0.5, on_idle, ee);
}

/**
 * @brief Internal callback that sets the vc_widget's foreground option to true.
 */
static void __vc_elm_event_window_focus_in(void *data, Evas_Object *obj, void *event_info)
{
	(void)data;
	(void)obj;
	(void)event_info;

	vc_widget_set_foreground(EINA_TRUE);

	VC_ELM_LOG_DBG("Focus in");
}

/*
 * @brief Internal callback that sets the vc_widget's foreground option to false
 */
static void __vc_elm_event_window_focus_out(void *data, Evas_Object *obj, void *event_info)
{
	(void)data;
	(void)obj;
	(void)event_info;

	vc_widget_set_foreground(EINA_FALSE);

	_vc_elm_turn_off_tooltips();

	VC_ELM_LOG_DBG("Focus out");
}

void _vc_elm_core_register_view_change_detection()
{
	Ecore_Evas *ecevas = NULL;
	ecevas = ecore_evas_ecore_evas_get(evas_object_evas_get(g_default_window));
	ecore_evas_callback_post_render_set(ecevas, __idle_changed);
}

void _vc_elm_core_unregister_view_change_detection()
{
	Ecore_Evas *ecevas = NULL;
	ecevas = ecore_evas_ecore_evas_get(evas_object_evas_get(g_default_window));
	ecore_evas_callback_post_render_set(ecevas, NULL);
}

static Eina_Bool __idle_enter(void *data)
{
	Eina_List *l;
	Evas_Object *obj;
	Eina_Bool is_focused = elm_win_focus_get(g_default_window);
	(void)data;

	if (NULL != g_default_window) {
		evas_object_smart_callback_del(g_default_window, "focused", __vc_elm_event_window_focus_in);
		evas_object_smart_callback_del(g_default_window, "unfocused", __vc_elm_event_window_focus_out);
	}

	VC_ELM_LOG_DBG("Focused g_default %ud", elm_win_xwindow_get(g_default_window));
	if (!is_focused) {
		/* window changed, we need to get new one */
		VC_ELM_LOG_DBG("list count %d", eina_list_count(ui_objects_list));
		EINA_LIST_FOREACH(ui_objects_list, l, obj) {
			Evas_Object *window = NULL;
			VC_ELM_LOG_DBG("foreach obj %p", (void*)obj);
			window = elm_object_top_widget_get(obj);
			if (window && elm_win_focus_get(window) == EINA_TRUE) {
				VC_ELM_LOG_DBG("NEW Focused g_default %ud", elm_win_xwindow_get(window));
				g_default_window = window;
				break;
			}
		}
	}

	evas_object_smart_callback_add(g_default_window, "focused", __vc_elm_event_window_focus_in, NULL);
	evas_object_smart_callback_add(g_default_window, "unfocused", __vc_elm_event_window_focus_out, NULL);

	/* OK, window set properly now */

	_vc_elm_set_tooltips_window(g_default_window);
	VC_ELM_LOG_DBG("elm_win_xwindow_get = %p", (void*)elm_win_xwindow_get(g_default_window));

	if (elm_win_wm_rotation_supported_get(g_default_window)) {
		int rots[4] = {0, 90, 180, 270};
		elm_win_wm_rotation_available_rotations_set(g_default_window, (const int*)&rots, 4);
		evas_object_smart_callback_add(g_default_window, "wm,rotation,changed", __rotation, g_default_window);
		VC_ELM_LOG_DBG("Added support for rotation");
	} else {
		VC_ELM_LOG_DBG("wm rotation supported get error");
	}

	g_current_ui_objects = _vc_elm_core_find_all_visible_objects();

	VC_ELM_LOG_DBG("adding commands");
	__vc_add_commands();
	VC_ELM_LOG_DBG("idle enter finish");
	return ECORE_CALLBACK_CANCEL;
}

static void __rotation(void *data, Evas_Object *obj, void *event_info)
{
	(void)data;
	(void)obj;
	(void)event_info;
	if (!g_tooltips_displayed)
		return;
	/*__show_or_hide_tooltips_callback(false);
	ecore_main_loop_iterate();
	__show_or_hide_tooltips_callback(true);
	ecore_main_loop_iterate();*/
}

const char *_vc_elm_get_custom_widget_name()
{
	return VC_ELM_CUSTOM_WIDGET_NAME;
}

int _vc_elm_core_read_xml_data()
{
	xmlDocPtr doc = NULL;
	xmlNodePtr root = NULL;
	xmlNodePtr main_node = NULL;
	xmlNodePtr cur = NULL;
	xmlNodePtr child = NULL;
	xmlNodePtr tmp = NULL;
	xmlChar *key = NULL;
	const char * charkey;

	VC_ELM_LOG_DBG("reading XML start");
	doc = xmlParseFile(VC_ELM_CONFIG_XML);
	if (doc == NULL) {
		VC_ELM_LOG_ERR("Failed to parse XML file");
		return VC_ELM_ERROR_OPERATION_FAILED;
	}

	main_node = xmlDocGetRootElement(doc);
	if (main_node == NULL) {
		VC_ELM_LOG_ERR("Empty XML document");
		xmlFreeDoc(doc);
		return VC_ELM_ERROR_OPERATION_FAILED;
	}

	root = main_node->xmlChildrenNode;
	do {
		VC_ELM_LOG_DBG("Root nodes mames %s", root->name);
		if (0 == xmlStrcmp(root->name, XML_CAST VC_ELM_TAG_BASE_NAME)) {
			cur = root->xmlChildrenNode;
			do {
				if (cur == NULL) {
					VC_ELM_LOG_ERR("Empty XML document");
					xmlFreeDoc(doc);
					return VC_ELM_ERROR_OPERATION_FAILED;
				}
				VC_ELM_LOG_DBG("cur->name %s", cur->name);
				if (0 == xmlStrcmp(cur->name, XML_CAST VC_ELM_TAG_ACTION_LIST)) {
					child = cur->xmlChildrenNode;
					VC_ELM_LOG_DBG("xml pointer last %s %p", cur->last->name, (void *)cur->last);
					do {
						if (0 == xmlStrcmp(child->name, XML_CAST VC_ELM_TAG_ACTION_GROUP)) {
							const char *action_name = NULL;
							tmp = child->xmlChildrenNode;
							do {
								if (0 == xmlStrcmp(tmp->name, XML_CAST VC_ELM_TAG_ACTION_NAME)) {
									key = xmlNodeGetContent(tmp);
									VC_ELM_LOG_DBG("action name %s", (char *)key);
									action_name = eina_stringshare_add((char *)key);
									xmlFree(key);
								} else if (0 == xmlStrcmp(tmp->name, XML_CAST VC_ELM_TAG_ACTION_COMMAND)) {
									const char *action_command = NULL;
									key = xmlNodeGetContent(tmp);
									VC_ELM_LOG_DBG("action command %s", (char *)key);
									if (action_name != NULL) {
										action_command = eina_stringshare_add((char *)key);
										eina_hash_add(g_config_action_map, action_name, action_command);
									}
									xmlFree(key);
								}
								tmp = tmp->next;
							} while (tmp != NULL);
						}
						child = child->next;
					} while (child != NULL);
				} else if (0 == xmlStrcmp(cur->name, XML_CAST VC_ELM_TAG_WIDGET_LIST)) {
					child = cur->xmlChildrenNode;
					do {
						if (0 == xmlStrcmp(child->name, XML_CAST VC_ELM_TAG_WIDGET_GROUP)) {
							const char *widget_name = NULL;
							tmp = child->xmlChildrenNode;
							do {
								if (0 == xmlStrcmp(tmp->name, XML_CAST VC_ELM_TAG_WIDGET_NAME)) {
									key = xmlNodeGetContent(tmp);
									VC_ELM_LOG_DBG("widget name %s", (char *)key);
									widget_name = eina_stringshare_add((char *)key);
									xmlFree(key);
								} else if (0 == xmlStrcmp(tmp->name, XML_CAST VC_ELM_TAG_WIDGET_ACTIONS)) {
									xmlNodePtr actions = tmp->xmlChildrenNode;
									Eina_List *actions_list = NULL;
									do {
										if (0 == xmlStrcmp(actions->name, XML_CAST VC_ELM_TAG_ACTION_NAME)) {
											const char *action_tag = NULL;
											key = xmlNodeGetContent(actions);
											VC_ELM_LOG_DBG("widget action name %s", (char*)key);
											action_tag = eina_stringshare_add((char*)key);
											actions_list = eina_list_append(actions_list, action_tag);
											xmlFree(key);
										}
										actions = actions->next;
									} while (actions != NULL);
									if (widget_name != NULL && actions_list != NULL)
										eina_hash_add(g_config_widget_map, widget_name, actions_list);
								}
								tmp = tmp->next;
							} while (tmp != NULL);
						}
						child = child->next;
					} while (child != NULL);
				} else if (0 == xmlStrcmp(cur->name, XML_CAST VC_ELM_TAG_HINT_GROUP)) {
					child = cur->xmlChildrenNode;
					do {
						if (0 == xmlStrcmp(child->name, XML_CAST VC_ELM_TAG_HINT_SHOW)) {
							key = xmlNodeGetContent(child);
							VC_ELM_LOG_DBG("hint show %s", (char*)key);
							if (g_tooltips_show)
								free(g_tooltips_show);
							g_tooltips_show = strdup((char*)key);
							xmlFree(key);
						} else if (0 == xmlStrcmp(child->name, XML_CAST VC_ELM_TAG_HINT_DIRECTION)) {
							key = xmlNodeGetContent(child);
							VC_ELM_LOG_DBG("hint direction %s", (char*)key);
							if (g_tooltips_default_direction)
								free(g_tooltips_default_direction);
							g_tooltips_default_direction = strdup((char*)key);
							xmlFree(key);
						} else if (0 == xmlStrcmp(child->name, XML_CAST VC_ELM_TAG_HINT_IMAGE)) {
							key = xmlNodeGetContent(child);
							VC_ELM_LOG_DBG("hint image %s", (char*)key);
							if (g_tooltips_image_path)
								free(g_tooltips_image_path);
							charkey = tzplatform_mkpath(TZ_SYS_RO_SHARE, (const char*)key);
							g_tooltips_image_path = strdup(charkey);
							xmlFree(key);
						}
						child = child->next;
					} while (child != NULL);
				}
				cur = cur->next;
			} while (cur != NULL);
		} else if (0 == xmlStrcmp(root->name, XML_CAST VC_ELM_TAG_BASE_INFO)) {
			cur = root->xmlChildrenNode;
			do {
				if (0 == xmlStrcmp(cur->name, XML_CAST VC_ELM_TAG_TIZEN_VERSION)) {
					key = xmlNodeGetContent(cur);
					VC_ELM_LOG_DBG("hint direction %s", (char*)key);
					xmlFree(key);
				} else if (0 == xmlStrcmp(cur->name, XML_CAST VC_ELM_TAG_PROFILE)) {
					key = xmlNodeGetContent(cur);
					VC_ELM_LOG_DBG("hint direction %s", (char*)key);
					xmlFree(key);
				} else if (0 == xmlStrcmp(cur->name, XML_CAST VC_ELM_TAG_EFL_VERSION)) {
					key = xmlNodeGetContent(cur);
					VC_ELM_LOG_DBG("hint direction %s", (char*)key);
					xmlFree(key);
				}
				cur = cur->next;
			} while (cur != NULL);
		}
		root = root->next;
	} while (root != NULL);

	xmlFreeDoc(doc);

	return VC_ELM_ERROR_NONE;
}

int _vc_elm_core_destroy_xml_data()
{

	if (g_tooltips_show) {
		free(g_tooltips_show);
		g_tooltips_show = NULL;
	}
	if (g_tooltips_default_direction) {
		free(g_tooltips_default_direction);
		g_tooltips_default_direction = NULL;
	}
	if (g_tooltips_image_path) {
		free(g_tooltips_image_path);
		g_tooltips_image_path = NULL;
	}
	return VC_ELM_ERROR_NONE;
}

int _vc_elm_core_get_tooltip_default_direction()
{
	if (NULL == g_tooltips_default_direction)
		return VC_ELM_DIRECTION_CENTER;

	if (!strcmp(g_tooltips_default_direction, "center"))
		return VC_ELM_DIRECTION_CENTER;
	else if (!strcmp(g_tooltips_default_direction, "left"))
		return VC_ELM_DIRECTION_LEFT;
	else if (!strcmp(g_tooltips_default_direction, "right"))
		return VC_ELM_DIRECTION_RIGHT;
	else if (!strcmp(g_tooltips_default_direction, "top"))
		return VC_ELM_DIRECTION_TOP;
	else if (!strcmp(g_tooltips_default_direction, "bottom"))
		return VC_ELM_DIRECTION_BOTTOM;
	else if (!strcmp(g_tooltips_default_direction, "left top"))
		return VC_ELM_DIRECTION_LEFT_TOP;
	else if (!strcmp(g_tooltips_default_direction, "left bottom"))
		return VC_ELM_DIRECTION_LEFT_BOTTOM;
	else if (!strcmp(g_tooltips_default_direction, "right top"))
		return VC_ELM_DIRECTION_RIGHT_TOP;
	else if (!strcmp(g_tooltips_default_direction, "right bottom"))
		return VC_ELM_DIRECTION_RIGHT_BOTTOM;
	else
		return VC_ELM_DIRECTION_CENTER;
}

const char *_vc_elm_core_get_tooltip_image_path()
{
	return (const char *)g_tooltips_image_path;
}

int _vc_elm_core_get_tooltip_show()
{
	if (NULL == g_tooltips_show)
		return EINA_FALSE;
	else if (0 == strcmp(g_tooltips_show, "on"))
		return EINA_TRUE;

	return EINA_FALSE;
}

void _vc_elm_core_set_view_changed()
{
	g_view_changed = EINA_TRUE;
	__idle_changed(NULL);
}
